串行GC：年轻代使用标记复制算法，老年代使用标记整理算法，都是使用单线程做GC，每次GC暂停的时间比较长，年轻代和老年代GC暂停的时间差不多。
并行GC：JAVA8默认的GC策略，年轻代使用标记复制算法，老年代使用标记整理算法。GC时会暂停业务线程，所有线程都用来垃圾回收，暂停时间比较短。在单核机器上由于线程交互的开销，效率没有串行GC高。适用于对吞吐量大的业务。
CMSGC：对老年代使用CMSGC，年轻代使用ParNew，也就是多线程的串行GC，年轻代使用标记复制算法，老年代使用标记清除算法。对老年代清理的四个过程中，初始标记和最终标记有GC暂停，其他阶段都是GC线程和业务线程并发执行。适用于对响应时间要求高的系统。因为GC之后对老年代没有整理，会出现内存碎片，当较大的对象要进入老年代时可能会没有空间分配，导致fullGC的发生。
G1GC：将堆内存分为一个个小的Rigon块，也分为年轻代和老年代，但是内存区间不是连续的。可以预测GC暂停的时间。